import { Platform } from "react-native";
import * as SQLite from 'expo-sqlite';
import { openDB } from "idb";
import 'react-native-get-random-values';
import { v4 as uuidv4 } from "uuid"; 
import { Buffer } from "buffer";

const dbURL = "http://192.168.68.52:5984"
const username = "admin"
const password = "admin"

export class DB {
  constructor({name, type="REMOTE", username = username, password = password, syncInterval = 30000}) {
    this.tableName = name ;
    this.couchUrl = dbURL;
    this.type = type
    this.isWeb = Platform.OS == "web"
    this.authHeader = "Basic " + Buffer.from(`${username}:${password}`).toString("base64");
    this.syncInterval = syncInterval;

    this.localDB = null;
    this.syncing = false;
  }

  /** Inicializa DB y arranca sync */
  async initDB() {
    console.log("Inicializando base de datos " + this.tableName + "...");
    try {
      if (this.isWeb) {
        this.localDB = await openDB(this.tableName, 1, {
          upgrade(db) {
            if (!db.objectStoreNames.contains("records")) {
              db.createObjectStore("records", { keyPath: "id" });
            }
          },
        });
      } else {
        this.localDB = await SQLite.openDatabaseAsync(this.tableName);

        await this.localDB.execAsync('PRAGMA journal_mode = WAL');
        await this.localDB.execAsync('PRAGMA foreign_keys = ON');
        //await this.localDB.execAsync('DROP TABLE IF EXISTS records')
  await this.localDB.execAsync('CREATE TABLE IF NOT EXISTS records (id TEXT PRIMARY KEY,data TEXT,updatedAt INTEGER,synced INTEGER DEFAULT 0,_rev TEXT)')
      }
      console.log("Base de datos " + this.tableName + " inicializada correctamente");
      // Sincronización inmediata al levantar la base
      if (this.type == "REMOTE")
      {
        await this.syncAllNow();
        this.startSync();
        this.listenChanges();
      }
    } catch (err) {
      console.error("Error inicializando DB:", err);
    }
  }
  /** Sincronización inmediata manual */
  async syncAllNow() {
    try {
      const records = await this.getAllToSync();
      for (const r of records.filter(r => r.synced === 0)) {
        await this.syncRecord(r);
      }
    } catch (err) {
      console.warn("Error en sincronización inicial:", err);
    }
  }

  
  /** Guardar o actualizar registro local */
  async saveLocal(data, id="", rev = "") {
    const updatedAt = Date.now();
    try{
      if (id =="") {id = uuidv4()}
    }
    catch (e){console.log (e)}

    // Si el registro está marcado como eliminado, guardar la marca
    const isDeleted = data && data.deleted === true;
  const record = { id: id =="" ? id = uuidv4() : id, data, updatedAt, synced: 0, _rev: rev || (data && data._rev ? data._rev : "") };

    try {
      if (this.isWeb) {
        await this.localDB.put("records", record);
        } else {
        await this.exec(
          `INSERT OR REPLACE INTO records (id, data, updatedAt, synced, _rev) VALUES (?, ?, ?, 0, ?)`,
          [id, JSON.stringify(data), updatedAt, record._rev]
        );
      }
      return id;
    } catch (err) {
      console.error("Error guardando local:", err);
      throw err;
    }
  }

  async exec(sql, params = []) {
  try {
    const result =  await this.localDB.getAllAsync (sql, params)
    return (result == undefined ? []: result)
  } catch (err) {
    console.log("error en execAsync", err);
    throw err;
  }
}
  async run(sql, params = []) {
  try {
    //const result = await this.localDB.runAsync(sql, params);
    await this.localDB.runAsync (sql, params)
    return true
  } catch (err) {
    console.log("error en run", err);
    return false
    throw err;
  }
}

  /** Obtener todos los registros locales */
  async getAll(sql, params = []) {
    try {
      let records;
      if (this.isWeb) {
        records = await this.localDB.getAll("records");
      } else {
        console.log ("muestro sql")
        console.log (sql)
        console.log (params)
        let result = await this.exec(sql, params);
        console.log (result)
        if (result == null) result = [];
        records = result.map(row => ({
          id: row.id,
          data: JSON.parse(row.data),
          updatedAt: row.updatedAt,
          synced: row.synced,
          _rev: row._rev || ''
        }));
      }
      
      // Filtrar registros eliminados
      return records.filter(r => !(r.data && r.data.deleted === true));
    } catch (err) {
      console.error("Error obteniendo registros locales:", err);
      return [];
    }
  }

  /** Obtener todos los registros locales */
  async getAllToSync() {
    try {
      let data;
      if (this.isWeb) {
        data = await this.localDB.getAll("records");
      } else {
        data = await this.getAll("SELECT * FROM records WHERE synced=0");
      }
      // Filtrar registros eliminados y solo los no sincronizados
      return data.filter(r => r.synced === 0 && !(r.data && r.data.deleted === true));
    } catch (err) {
      console.error("Error obteniendo registros locales a sincronzizar:", err);
      return [];
    }
  }

  /** Marcar registro como sincronizado */
  async markSynced(id, rev = null) {
    if (this.isWeb) {
      const record = await this.localDB.get("records", id);
      if (record) {
        record.synced = 1;
        if (rev) record._rev = rev;
        await this.localDB.put("records", record);
      }
    } else {
      if (rev) {
        await this.exec(`UPDATE records SET synced = 1, _rev = ? WHERE id = ?`, [rev, id]);
      } else {
        await this.exec(`UPDATE records SET synced = 1 WHERE id = ?`, [id]);
      }
    }
  }

  /** Sincroniza un registro con CouchDB */
  async syncRecord(record) {
    try {
      // Si el registro está eliminado, eliminar también en remoto si existe
      if (record.data && record.data.deleted === true) {
        // Intentar eliminar en remoto
        const res = await fetch(`${this.couchUrl}/${this.tableName}/${record.id}`, {
          headers: { Authorization: this.authHeader },
        });
        if (res.ok) {
          const remote = await res.json();
          if (remote._rev) {
            await fetch(`${this.couchUrl}/${this.tableName}/${record.id}?rev=${remote._rev}`, {
              method: "DELETE",
              headers: { Authorization: this.authHeader },
            });
          }
        }
        await this.markSynced(record.id);
        return;
      }

      const docToSave = { _id: record.id, data: record.data, updatedAt: record.updatedAt };
      const res = await fetch(`${this.couchUrl}/${this.tableName}/${record.id}`, {
        headers: { Authorization: this.authHeader },
      });

      if (res.status === 404) {
        // Documento no existe en remoto → crear
        const r = await fetch(`${this.couchUrl}/${this.tableName}/${record.id}`, {
          method: "PUT",
          headers: { Authorization: this.authHeader, "Content-Type": "application/json" },
          body: JSON.stringify(docToSave),
        });
        if (r.ok) {
          try {
            const result = await r.json();
            await this.markSynced(record.id, result.rev || result._rev || null);
          } catch (e) {
            await this.markSynced(record.id, null);
          }
        }
      } else {
        const remote = await res.json();
        // Resolver conflicto por fecha
        if (!remote._rev || remote.updatedAt < record.updatedAt) {
          // Local más reciente → actualizar remoto
          const r = await fetch(`${this.couchUrl}/${this.tableName}/${record.id}?rev=${remote._rev}`, {
            method: "PUT",
            headers: { Authorization: this.authHeader, "Content-Type": "application/json" },
            body: JSON.stringify({ ...docToSave, _rev: remote._rev }),
          });
          if (r.ok) {
            try {
              const result = await r.json();
              await this.markSynced(record.id, result.rev || result._rev || null);
            } catch (e) {
              await this.markSynced(record.id, null);
            }
          }
        } else if (remote.updatedAt > record.updatedAt) {
          // Remoto más reciente → actualizar local
          // Si el remoto está eliminado, eliminar localmente
          if (remote.data && remote.data.deleted === true) {
            await this.delete(record.id);
          } else {
            // Guardar la rev recibida desde remoto junto con los datos
            await this.saveLocal(remote.data, remote._id, remote._rev || remote.rev || "");
            await this.markSynced(remote._id, remote._rev || remote.rev || null);
          }
        }
      }
    } catch (err) {
      console.warn("Error sincronizando registro, se reintentará:", record.id, err);
    }
  }

  /** Sincronización periódica */
  async startSync() {
    if (this.syncing) return;
    this.syncing = true;

    // Ejecutar sincronización inmediatamente
    const doSync = async () => {
      const records = await this.getAllToSync();
      for (const r of records.filter(r => r.synced === 0)) {
        await this.syncRecord(r);
      }
    };

    doSync(); // Primera sincronización inmediata
    setInterval(doSync, this.syncInterval);
  }

  /** Longpoll para cambios remotos */
  async listenChanges() {
    const poll = async () => {
      try {
        const res = await fetch(`${this.couchUrl}/${this.tableName}/_changes?feed=longpoll&since=now`, {
          headers: { Authorization: this.authHeader, Accept: "application/json" },
        });
        const text = await res.text();
        if (text.startsWith("{")) {
          const changes = JSON.parse(text);
          for (const c of changes.results) {
            const docRes = await fetch(`${this.couchUrl}/${this.tableName}/${c.id}`, {
              headers: { Authorization: this.authHeader, Accept: "application/json" },
            });
            const doc = await docRes.json();
            // Si el remoto está eliminado, eliminar localmente
            if (doc.data && doc.data.deleted === true) {
              await this.delete(doc._id);
            } else {
              await this.saveLocal(doc.data, doc._id);
              await this.markSynced(doc._id);
            }
          }
        } else {
          console.error("Respuesta inesperada:", text);
        }
      } catch (err) {
        console.warn("Error longpoll:", err);
      } finally {
        setTimeout(poll, 5000);
      }
    };
    poll();
  }

  /** API simple */
  async add(data, idRecord) {
    const id = await this.saveLocal(data, idRecord);
    // Si no hay sincronización en curso, iniciar sincronización manual
    if (!this.syncing) {
      this.startSync();
    }
    return id;
  }

  async get(id) {

    if (this.isWeb)
    {
      const all = await this.getAll();
      return all.find(r => r.id === id) || null;
    }
    console.log (id)
    console.log ("voy a buscar get")
    let aux = await this.getAll("SELECT * FROM records where id=?", [id])
    if (aux == []) return {}
    console.log ("retrorno de get")
    console.log (aux[0].data)
    return aux[0].data
    
  }
async getWithHeader(id) {

    if (this.isWeb)
    {
      const all = await this.getAll();
      return all.find(r => r.id === id) || null;
    }
    console.log (id)
    console.log ("voy a buscar getheader")
    let aux = await this.getAll("SELECT * FROM records where id=?", [id])
    if (aux == []) return {}
    console.log ("retrorno de getheader")
    console.log (aux[0])
    return aux[0]
    
  }

  async update(id, newData) {
    const result = await this.saveLocal(newData, id);
    // Si no hay sincronización en curso, iniciar sincronización manual
    if (!this.syncing) {
      this.startSync();
    }
    return result;
  }

  async delete(id) {
    try {
      if (this.isWeb) await this.localDB.delete("records", id);
      else await this.localDB.execAsync(`DELETE FROM records WHERE id = ?`, [id]);

      // Eliminar remoto
      const res = await fetch(`${this.couchUrl}/${this.tableName}/${id}`, {
        headers: { Authorization: this.authHeader },
      });
      if (res.ok) {
        const doc = await res.json();
        await fetch(`${this.couchUrl}/${this.tableName}/${id}?rev=${doc._rev}`, {
          method: "DELETE",
          headers: { Authorization: this.authHeader },
        });
      }
    } catch (err) {
      console.warn("Error borrando remoto:", err);
    }
  }
}
